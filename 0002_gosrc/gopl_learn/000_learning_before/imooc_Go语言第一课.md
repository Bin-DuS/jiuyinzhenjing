# go语言特点
1. 静态类型，编译型的语言
    * var num1 int = 1
    * num2 := 2 #推导出变量类型为 int
2. 脚本话的语法，语法较为松散，支持多种编程范式，约束较少
3. 函数式&面向对象
4. 原生的并发编程支持 go routine
# go语言
1. 优势
    * 脚本化的语法
    * 静态类型+编译型，程序运行速度有保障，比动态解释型语言效率高很多
    * 原生支持并发编程，降低开发维护成本，程序更好的执行
2. 劣势
    * 语法糖没有python和ruby那么多（语法越灵活，维护成本越高，go语言相对python等不是那么灵活，反而是一种优点，10%的时间开发，90%的时间维护）
    * 程序运行速度不及C语言，运行效率已经超过C++、Java
    * go语言兴起不久，第三方函数库暂时不像绝对主流的编程语言那么多（第三方库也越来越多）
# 常用概念和定义
1. 工作区和GOPATH
    * 放置Go源码文件的目录
    * 一般情况下，Go源码文件都需要存放到工作区中
    * 命令源码文件不一定要存放在工作区
        ```
        目录结构
        project
            src/        存放源码文件，以代码包为组织形式
            pkg/        用于存放归档文件，一般为代码包.a文件，所有归档文件都会存放到该目录下的平台相关目录中，同样以代码包位组织形式
            bin/        用于存放当前工作区中的Go程序的可执行文件 和GOBIN作用相似
    * 平台相关目录指两个隐含的Go语言环境变量 GOOS(系统类型：windows、Linux、darwin、Solaris...)和GOARCH(amd64、arm、arm64...) 以$GOOS_$GOARCH为命名方式，如：linux_amd64
        ```
        <workdir>/pkg/<平台相关目录>/<一级代码包>/<二级代码包>/.../<末级代码包>.a
    * bin目录在以下两种情况下没有意义
        1. 当环境变量GOBIN已有效设置时，该目录会变的没有意义
        2. 当GOPATH的值中包含多个工作区的路径时，必须设置GOBIN，否则无法成功安装Go程序的可执行文件
2. 源码文件的分类和含义 名称以.go为后缀，内容以Go语言代码组织的文件
    * 多个Go源码文件是需要用代码包组织起来的
    * 分三类：
        1. 命令源码文件     都有一定功能的 go语言程序
            ```
            声明自己属于main代码包，包含无参数声明和结果声明的main函数
            被安装后，相应的可执行文件会被存放到GOBIN指向的目录或<当前工作区目录>/bin下
            命令源码文件是go程序的入口，但不建议把程序都写在一个文件中
            同一个代码包中不建议直接包含多个命令源码文件
        2. 库源码文件，     都有一定功能的 go语言程序
            ```
            不具备命令源码文件的两个特征的源码文件（包含main代码包和main函数）
            被安装后，相应的归档文件会被存放到<当前工作区目录>/pkg/<平台相关目录>下
        3. 测试源码文件                 辅助源码文件，用来测试上面功能性源码文件。功能源码文件_test.go
            ```
            不具备命令源码文件的两个特征的源码文件
            名称以_test.go为后缀
            其中至少有一个函数的名称以Test（功能测试函数）或者Benchmark（基准测试函数，也叫性能测试函数）为前缀
            分别接受一个类型为*testing.T或*testing.B的参数
3. 代码包相关知识
    1. 代码包的作用
        * 编译和归档Go程序的基本单位
        * 代码划分、集结和依赖的有效组织形式，也是权限控制的辅助手段
    2. 代码包规则
        * 一个代码包实际上就是一个由导入路径代表的目录
        * 导入路径即<工作区目录>/src或<工作区目录>/pkg/<平台相关目录>之下的某段子路径
        * 每个源码文件必须声明其所属的代码包
        * 同一个代码包中的所有源码文件声明的代码包应该是相同的
    3. 代码包声明与代码包导入路径的区别
        * 代码宝声明语句中的包名称应该是该代码包的导入路径的最右子路径
    4. 代码包导入
        * 代码包导入语句中使用的包名称应该与其导入路径一致
    5. 代码包导入方法
        * import str "strings" 别名，可以用str.HasPrefix()
        * import . "strings" 本地化导入 可以用HasPrefix()
        * import _ "strings" 仅仅初始化，并不调用任何函数
    6. 代码包的初始化
        * 代码包初始化函数，无参数声明和结果声明的init函数
        * init函数可以被声明在任何文件中，且可以多个
        * init函数的执行时机--
            1. 在程序入口之前即 main之前
            2. 每个init函数只执行一次
            ```
            单一代码包内
            对所有全局变量进行求值，执行所有init函数，同一个代码包内多个init函数执行顺序是不确定的，不能对此做任何假设
            ```
            ```
            不同代码包之间
            执行被导入的代码包中的init函数，再执行导入它的那个代码包的init函数
            同时导入多个代码包，不能假设同时导入的代码包的init执行顺序
# 命令基础
1. go run
    * 用于运行源码文件
    * 只能接受一个命令源码文件以及若干库源码文件作为文件参数
        ```
        先编译源码文件放到临时文件夹中，再运行
    * 常用标记的使用
        1. -a 强制编译相关代码，不论它们的编译结果是否已经是最新的，默认是不会重复编译的
        2. -n 打印编译过程中所需运行的命令，但不真正执行它们
        3. -p n 并行编译，其中n为并行的数量，最好值设置为逻辑cpu的个数
        4. -v 列出被编译的代码包的名称
        5. -work 显示编译时创建的临时工作目录的路径，并且不删除它，（默认情况下在执行结束后删除）
        6. -x 打印编译过程中所需运行的命令 与-n的区别是进行编译了
        7. 举例 
            ```
            go run -n test.go
            go run -x test.go
            go run -v test.go
            go run -work test.go
2. go build
    * 用于编译源码文件或代码包
    * 编译非命令源码文件不会产生任何结果文件
    * 编译命令源码文件会在该命令的执行目录中生成一个可执行文件
    * 执行该命令且不追加任何参数时，它会试图把当前目录作为代码包并编译
    * 执行该命令且以代码包的导入路径作为参数时，该代码包及其依赖会被编译
    * 加入 -a 标记后所有涉及到的代码包都会被重新编译（默认条件下只会编译归档文件不是最新的代码包）
    * 执行该命令且以若干源码文件作为参数时，只有列出的源码文件会被编译
3. go install
    * 用于编译并安装代码包或源码文件
    * 安装代码包会在当前工作区的pkg/<平台相关目录>下生成归档文件
    * 安装命令源码文件会在当前工作区的bin目录或$GOBIN目录下生成可执行文件
    * 执行该命令且不追加任何参数时，试图把当前目录作为代码包并安装
    * 执行该命令且以代码包的导入路径作为参数时，该代码包及其依赖会被安装
    * 执行该命令且以命令源码文件及相关库源码文件作为参数时，只有这些文件会被编译并安装
4. go get
    * 用于从远程代码仓库上下载并安装代码包
    * 受支持的代码版本控制仓库有：Git、Mercurial(hg)、SVN、Bazarr
    * 指定的代码包会被下载到$GOPATH中包含的第一个工作区的src目录中
    * 常用标记
        1. -d 只执行下载动作，并不执行安装动作
        2. -fix 在下载代码包后先执行修正动作，然后再进行编译安装 代码包可能是在低版本go下实现的进行修正后在当前go版本中使用
        3. -u 利用网络来更新已有的代码包及其依赖包


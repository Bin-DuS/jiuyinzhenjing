goroutine是非常轻量的，不会暂用太多资源，基本上有多少任务，我们可以开多少goroutine去处理。但有时候，我们还是想控制一下。

比如，我们有A、B两类工作，不想把太多资源花费在B类务上，而是花在A类任务上。对于A，我们可以来1个开一个goroutine去处理，对于B，我们可以使用一个协程池，协程池里有5个线程去处理B类任务，这样B消耗的资源就不会太多。

控制使用资源并不是协程池目的，使用协程池是为了更好并发、程序鲁棒性、容错性等。废话少说，快速入门协程池才是这篇文章的目的。

协程池指的是预先分配固定数量的goroutine处理相同的任务，和线程池是类似的，不同点是协程池中处理任务的是协程，线程池中处理任务的是线程。

最简单的协程池的样子。先把协程池作为一个整体看，它使用2个通道，左边的jobCh是任务通道，任务会从这个通道中流进来，右边的retCh是结果通道，协程池处理任务后得到的结果会写入这个通道。至于协程池中，有多少协程处理任务，这是外部不关心的。

协程池内每个协程从jobch读取任务，处理完后将任务写入retch

最简单的协程池模型就这么简单，再回头看下协程池及周边由哪些组成：

    协程池内的一定数量的协程。
    任务队列，即jobCh，存在协程池不能立即处理任务的情况，所以需要队列把任务先暂存。
    结果队列，即retCh，同上，协程池处理任务的结果，也存在不能被下游立刻提取的情况，要暂时保存。

协程池最简要（核心）的逻辑是所有协程从任务读取任务，处理后把结果存放到结果队列。
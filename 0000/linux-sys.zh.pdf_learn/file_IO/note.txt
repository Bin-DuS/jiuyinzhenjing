001 linux系统函数是内核提供给应用的接口。
002 linux提供的函数可以使用Man Page查看
003 c标准函数和系统函数的区别在于系统函数有用户空间和内核空间，标准函数只有用户空间
004 每一个FILE文件流都有一个缓冲区buffer，默认大小8192Byte
005 write系统调用位于C标准库I/0缓冲区的底层，write的底层也可以分配一个内核I/O缓冲区，write也有可能写入到内核I/O缓冲区，
	如果A进程和B进程同时打开同一文件，进程A写到内核I/0缓冲区中的数据从B进程也能读到，C标准库的I/0缓冲区不具备这个特性
	（想想为什么，因为内核空间是共享的,进程的用户空间是完全独立的）
	相关资料：https://www.cnblogs.com/orlion/p/6258691.html
	全缓冲：read一次之后，将数据写入缓冲区，_IO_read_ptr没有偏移到_IO_read_end就不用调用系统调用read，
			只要将数据从myfile的缓冲区拷贝到buf即可。
			_IO_read_base始终指向缓冲区的开始
			_IO_read_end始终指向已经从内核读入缓冲区的字符的下一个（对全缓冲区来说，buffered I/O读每次都试图将缓冲区读满）
			_IO_read_ptr始终指向缓冲区中已经被用户读走的字符的下一个
				(_IO_read_end < (_IO_buf_base-_IO_buf_end)) && (_IO_read_ptr == _IO_read_end)
				时则已经到达文件末尾其中_IO_buf_base-_IO_buf_end是缓冲区的长度
			第一次fgets(或其他的)时,标准I/O会调用read将缓冲区充满,下一次fgets不调用read而是直接从
			该缓冲区中拷贝数据,直到缓冲区的中剩余的数据不够时,再次调用read.在这个过程中,_IO_read_ptr
			就是用来记录缓冲区中哪些数据是已读的,哪些数据是未读的.
			只有当标准I/O自动flush(比如当缓冲区已满时)或者手工调用fflush时,标准I/O才会调用一次write系统调用.
			例子中,fwrite(buf+i, 1, 512, myfile);这一句只是将buf+i接下来的512个字节写入缓冲区,由于缓冲区未满,
			标准I/O并未调用write.此时,myfile->_IO_write_ptr = myfile->_IO_write_base;会导致标准I/O认为没有数据写
			入缓冲区,所以永远不会调用write,这样aaa.txt文件得不到写入.注释掉myfile->_IO_write_ptr = myfile->_IO_write_base;
			前后,看看效果
　　		写的时候:_IO_write_base始终指向缓冲区的开始，_IO_write_end全缓冲的时候,始终
			指向缓冲区的最后一个字符的下一个(对全缓冲来说,buffered I/O写总是试图在缓冲区写满之后,再系统调用write)，
			_IO_write_ptr始终指向缓冲区中已被用户写入的字符的下一个，flush的时候,将_IO_write_base和_IO_write_ptr之
			间的字符通过系统调用write写入内核
	行缓冲：仅仅需要4个字符,但是,输入行中的其他数据也被写入缓冲区,但是_IO_read_ptr
			向前移动了5位,下次再次调用fgets操作时,就不需要再次调用系统调用read,只要将
			数据从stdin的缓冲区拷贝到buf2即可(从stdin->_IO_read_ptr开始拷贝)
			stdin->_IO_read_ptr = stdin->_IO_read_end;会导致标准I/O会认为缓冲区已空,
			再次fgets则需要再次调用read.
　　		_IO_read_base始终指向缓冲区的开始
　　		_IO_read_end始终指向已从内核读入缓冲区的字符的下一个
　　		_IO_read_ptr始终指向缓冲区中已被用户读走的字符的下一个
　　		(_IO_read_end < (_IO_buf_base-_IO_buf_end)) && (_IO_read_ptr == _IO_read_end)时
			则已经到达文件末尾其中_IO_buf_base-_IO_buf_end是缓冲区的长度
			行缓冲时,下面3个条件之一会导致缓冲区立即被flush
　　		1. 缓冲区已满
　　		2. 遇到一个换行符;比如将上面例子中buf[4]改为'/n'时
　　		3. 再次要求从内核中得到数据时;比如上面的程序加上getchar()会导致马上输出
　　		行缓冲写的时候:
　　		_IO_write_base始终指向缓冲区的开始
　　		_IO_write_end始终指向缓冲区的开始
　　		_IO_write_ptr始终指向缓冲区中已被用户写入的字符的下一个
　　		flush的时候,将_IO_write_base和_IO_write_ptr之间的字符通过系统调用write写入内核
	无缓冲：标准I/O不对字符进行缓冲存储.典型代表是stderr。这里的无缓冲,并不是指缓冲区大小为0,其实,还是有缓冲的,大小为1，对无缓冲的流的每次读写操作都会引起系统调用
	feof的问题：
			这里从缓冲区的角度去考察一下.对于一个空文件,为什么要先读一下,才能用feof判断出该文件到了结尾了呢?
			每当满足(_IO_read_end < (_IO_buf_base-_IO_buf_end)) && (_IO_read_ptr == _IO_read_end)时,
			标准I/O则认为已经到达文件末尾,feof(stdin)才会被设置其中_IO_buf_base-_IO_buf_end是缓冲区的长度。
　　		也就是说,标准I/O是通过它的缓冲区来判断流是否要结束了的.这就解释了为什么即使是一个空文件,标准I/O也
			需要读一次,才能使用feof判断释放为空。

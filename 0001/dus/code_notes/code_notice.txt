写日志准则
0.初衷:方便快速定位问题,描述正常运行的一些状态
1.不要把日志写在caller多的函数中。（会打印较多的日志）
2.减少日志总数。
3.关键节点记录日志。
4.错误一定要记录日志。
5.正常运行时理论上不产生日志。任务结束时需要打印日志，意外/错误需要打印日志，根据严重性打印不同等级的日志
6.心跳日志一定要简洁明了，或者在心跳失败时打印日志一般只在发生时打印一次
7.返回值需要有特定操作结果描述，一般0是成功，-1 -2 -3 -4 对应不同的失败原因 ，参数为NULL，-1 打开文件失败 -2 。。。。自定义返回值从 -101开始，分模块标记错误码
8.业务开始/结束标记
验证任务重启，可以先关闭watchdog，看server死掉的位置

长久保存的东西一定要转存文件，数据库等，防止程序运行完毕丢失数据

日志分级

6个日志等级:TRACE/DEBUG/INFO/WARNING/ERROR/FATAL
为了更好的使用日志系统，需要清楚的知道每个日志级别的功能定位和特点。

默认输出标准：
终端：DEBUG（含DEBUG）级别以上日志会被实时输出到终端（标准输出）。
默认情况下，TRACE不打印到终端。
文件：INFO（含INFO）级别以上日志会被归档到日志文件。
默认情况下，TRACE和DEBUG均不记入日志文件。

    TRACE
    TACE的主要使用目的是在线调试。
    该级别日志，默认情况下，既不打印到终端也不输出到文件。此时，对程序运行效率几乎不产生影响。
    在程序运行过程中，如果需要查看TRACE级别日志，需要通过elog命令开启TRACE或者将程序日志输出级别降至TRACE。

.

    DEBUG
    DEUG的主要使用目的是终端查看和在线调试。
    该级别日志，默认情况下会打印到终端输出，但是不会归档到日志文件。因此，一般用于开发者在程序当前启动窗口上，查看日志流水信息。
    在程序启动命令行中加入 “-nostdout” ,将关闭所有前端打印输出（主要针对DEBUG级别日志）。

.

    INFO
    INFO的主要使用目的报告程序进度和转态信息。一般这种信息都是一过性的，不会大量反复输出。例如：连接商用库成功后，可以打印一条连库成功的信息，便于跟踪程序进展信息。
    该级别日志，默认情况下会同时打印到终端和归档到日志文件（下同）。

.

    WARNING
    警告信息，表明程序处理中遇到非法数据或者某种可能的错误，该错误是一过性的、可恢复的，不会影响程序继续运行，程序仍处在正常状态。

.

    ERROR
    该错误发生后程序仍然可以运行，但是极有可能运行在某种非正常的状态下，导致无法完成全部既定的功能。

.

    FATAL
    致命的错误，表明程序遇到了致命的错误，必须马上终止运行。
	日志输出注意事项

    1.规范错误码
    函数返回值：
    函数返回值尽量作为错误码标识，不建议返回出参，如用于对象指针、记录条数等信息的输出。除带有是否判断意义的函数外，应采用int类型表示错误码，不建议采用bool类型。
    正确情况：
    返回码必须为0 值
    错误情况：
    返回码必须为 小于0 值，建议对于典型错误进行编码（而不是一律-1）。
    对于错误情况，要记录相关日志。

.

    2.如何选择日志级别
    考虑因素：1）输出频率 2）严重级别
    输出频率
    对于高频输出的日志，一定要用log_trace，否则严重影响程序执行效率、日志文件很快就会被打满和覆盖。因此，For、while循环中的日志，一定要用log_trace()
    严重级别
    执行错误：必须采用log_warn()以上级别输出。
    非执行错误信息： 如调试、追踪等日志信息，一定采用log_info以下级别打印，建议采用log_trace或者log_debug。
    log_info只适用于输出频率不高的情况或者需要记录到日志文件中，便于问题追忆的需求。

.

    3.哪些信息需要记日志
    1）异常、错误信息
    2）调试、追踪信息，具体包括：
    函数入参：与其他模块交互的程序（接口函数），最好采用log_debug记录“输入参数”信息，便于问题分析。
    执行步骤：对于关键功能函数，应该划分执行步骤，在每一步成功执行后，采用log_trace/log_debug记录，便于跟踪和掌控程序当前执行情况。
    数据流：例如scada从fes接收到的采集数据相关信息。

你应该写有意义的log

这可能是最重要的建议了。没有什么比你深刻理解程序内部，却写出含糊的log更糟了。

在你写日志信息之前，总要提醒自己，有突发事件的时候，你唯一拥有的只有来自log文件，你必须从中明白发生了什么。这可能就是被开除和升职之间的微妙的差距。

当开发者写log的时候，它(log语句)是直接写在代码环境中的，在各种条件中我们应该写入基于当前环境的信息。不幸的是，在log文件中并没有这些环境，这可能导致这些信息无法被理解。

解决这个情况(在写warn和error level时尤为重要)的一个方法是，添加辅助信息到log信息中，如果做不到，那么改为把这个操作的作用写下。

还有，不要让一个log信息的内容基于上一个。这是因为前面的信息可能由于(与当前信息)处于不同的类别或者level而没被写入。更坏的情况是，它因多线程或异步操作，在另一个地方(或是以另一方式)出现。
如果获取不到值只能返回失败
		if (-1 == GetSwitchStr("ETH", "ethname", &ETH, SYS_CONF_INI_FILE_NAME))
    	{
    		//close(sockfd);
    		ETH = "eth0";
        	//return -6;
    	}
进行重复获取，直到获取到值
		do{
			DEBUG("GetSwitchStr\n");
		}while(-1 == GetSwitchStr("ETH", "ethname", &ETH, SYS_CONF_INI_FILE_NAME));
001 linux系统函数是内核提供给应用的接口。
002 linux提供的函数可以使用Man Page查看
003 c标准函数和系统函数的区别在于系统函数有用户空间和内核空间，标准函数只有用户空间
004 每一个FILE文件流都有一个缓冲区buffer，默认大小8192Byte
005 write系统调用位于C标准库I/0缓冲区的底层，write的底层也可以分配一个内核I/O缓冲区，write也有可能写入到内核I/O缓冲区，
	如果A进程和B进程同时打开同一文件，进程A写到内核I/0缓冲区中的数据从B进程也能读到，C标准库的I/0缓冲区不具备这个特性
	（想想为什么，因为内核空间是共享的,进程的用户空间是完全独立的）
	相关资料：https://www.cnblogs.com/orlion/p/6258691.html
	全缓冲：read一次之后，将数据写入缓冲区，_IO_read_ptr没有偏移到_IO_read_end就不用调用系统调用read，
			只要将数据从myfile的缓冲区拷贝到buf即可。
			_IO_read_base始终指向缓冲区的开始
			_IO_read_end始终指向已经从内核读入缓冲区的字符的下一个（对全缓冲区来说，buffered I/O读每次都试图将缓冲区读满）
			_IO_read_ptr始终指向缓冲区中已经被用户读走的字符的下一个
				(_IO_read_end < (_IO_buf_base-_IO_buf_end)) && (_IO_read_ptr == _IO_read_end)
				时则已经到达文件末尾其中_IO_buf_base-_IO_buf_end是缓冲区的长度
			第一次fgets(或其他的)时,标准I/O会调用read将缓冲区充满,下一次fgets不调用read而是直接从
			该缓冲区中拷贝数据,直到缓冲区的中剩余的数据不够时,再次调用read.在这个过程中,_IO_read_ptr
			就是用来记录缓冲区中哪些数据是已读的,哪些数据是未读的.
			只有当标准I/O自动flush(比如当缓冲区已满时)或者手工调用fflush时,标准I/O才会调用一次write系统调用.
			例子中,fwrite(buf+i, 1, 512, myfile);这一句只是将buf+i接下来的512个字节写入缓冲区,由于缓冲区未满,
			标准I/O并未调用write.此时,myfile->_IO_write_ptr = myfile->_IO_write_base;会导致标准I/O认为没有数据写
			入缓冲区,所以永远不会调用write,这样aaa.txt文件得不到写入.注释掉myfile->_IO_write_ptr = myfile->_IO_write_base;
			前后,看看效果
　　		写的时候:_IO_write_base始终指向缓冲区的开始，_IO_write_end全缓冲的时候,始终
			指向缓冲区的最后一个字符的下一个(对全缓冲来说,buffered I/O写总是试图在缓冲区写满之后,再系统调用write)，
			_IO_write_ptr始终指向缓冲区中已被用户写入的字符的下一个，flush的时候,将_IO_write_base和_IO_write_ptr之
			间的字符通过系统调用write写入内核
	行缓冲：仅仅需要4个字符,但是,输入行中的其他数据也被写入缓冲区,但是_IO_read_ptr
			向前移动了5位,下次再次调用fgets操作时,就不需要再次调用系统调用read,只要将
			数据从stdin的缓冲区拷贝到buf2即可(从stdin->_IO_read_ptr开始拷贝)
			stdin->_IO_read_ptr = stdin->_IO_read_end;会导致标准I/O会认为缓冲区已空,
			再次fgets则需要再次调用read.
　　		_IO_read_base始终指向缓冲区的开始
　　		_IO_read_end始终指向已从内核读入缓冲区的字符的下一个
　　		_IO_read_ptr始终指向缓冲区中已被用户读走的字符的下一个
　　		(_IO_read_end < (_IO_buf_base-_IO_buf_end)) && (_IO_read_ptr == _IO_read_end)时
			则已经到达文件末尾其中_IO_buf_base-_IO_buf_end是缓冲区的长度
			行缓冲时,下面3个条件之一会导致缓冲区立即被flush
　　		1. 缓冲区已满
　　		2. 遇到一个换行符;比如将上面例子中buf[4]改为'/n'时
　　		3. 再次要求从内核中得到数据时;比如上面的程序加上getchar()会导致马上输出
　　		行缓冲写的时候:
　　		_IO_write_base始终指向缓冲区的开始
　　		_IO_write_end始终指向缓冲区的开始
　　		_IO_write_ptr始终指向缓冲区中已被用户写入的字符的下一个
　　		flush的时候,将_IO_write_base和_IO_write_ptr之间的字符通过系统调用write写入内核
	无缓冲：标准I/O不对字符进行缓冲存储.典型代表是stderr。这里的无缓冲,并不是指缓冲区大小为0,其实,还是有缓冲的,大小为1，对无缓冲的流的每次读写操作都会引起系统调用
	feof的问题：
			这里从缓冲区的角度去考察一下.对于一个空文件,为什么要先读一下,才能用feof判断出该文件到了结尾了呢?
			每当满足(_IO_read_end < (_IO_buf_base-_IO_buf_end)) && (_IO_read_ptr == _IO_read_end)时,
			标准I/O则认为已经到达文件末尾,feof(stdin)才会被设置其中_IO_buf_base-_IO_buf_end是缓冲区的长度。
　　		也就是说,标准I/O是通过它的缓冲区来判断流是否要结束了的.这就解释了为什么即使是一个空文件,标准I/O也
			需要读一次,才能使用feof判断释放为空。
006 一个进程默认打开3个文件描述符
		STDIN_FILENO 0
		STDOUT_FILENO 1
		STDERR_FILENO 2
		新打开文件返回文件描述符表中未使用的最小文件描述符，open函数可以打开或者创建一个文件
		int open(const char *filename,int flags,...);
		返回值为分配的文件描述符，出错返回-1并设置errno
		filename 可以是将对路径也可以是绝对路径
		flags 一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义
		都以O_开头，表示or。
		必选项：以下三个常数中必须指定一个，且仅允许指定一个。
			O_RDONLY 只读打开
			O_WRONLY 只写打开
			O_RDWR 可读可写打
		可选项:和必选项按位或作为参数
			O_APPEND 追加
			O_CREAT 文件不存在创建文件
			O_EXCL 如果同时指定了O_CREAT文件存在，则出错返回
			O_TRUNC 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断（Trun-cate）为0字节。
			O_NONBLOCK 对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I/O（Nonblock I/O），非阻塞I/O在下一节详细讲解。
		第三个参数mode指定文件权限，可以用八进制数表示 如0666，也可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示
007 umask 创建文件时权限为umask&~022 如 0666&~022=0644
008 int close(int fd)
	成功返回0，出错返回-1并设置errno
	当一个进程终止时，内核对该进程尚未关闭的文件描述符调用close关闭。
	不过长时间运行的进程，还是需要程序员手动去关闭，否则打开太多，不能再打开了。
	open返回的文件描述符一定是该进程尚未使用的最小描述符
	由于程序启动时自动打开文件描述符0、1、2，因此第一次调用open打开文件通常会返回描述符3
009 最大打开文件
	cat /proc/sys/fs/file-max
	ulimit -a 查看的信息比较多
	ulimit -n 4096 修改默认设置最大打开文件个数为4096
010 int read(int fd,void *buf,size_t count);
	从描述符fd中读取count个字符到缓冲区buf，同时读写位置后移
	这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写
	位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。比
	如用fgetc读一个字节，fgetc有可能从内核中预读1024个字节到I/O缓冲区中，再返回第一
	个字节，这时该文件在内核中记录的读写位置是1024，而在FILE结构体中记录的读写位置是
	1。注意返回值类型是ssize_t，表示有符号的size_t，这样既可以返回正的字节数、0（表
	示到达文件末尾）也可以返回负值-1（表示出错）。read函数返回时，返回值说明了buf中
	前多少个字节是刚读上来的。有些情况下，实际读到的字节数（返回值）会小于请求读的字
	节数count，
	读常规文件时，在读到count个字节之前已到达文件末尾。例如，距文件末尾还有30个
	字节而请求读100个字节，则read返回30，下次read将返回0。
	从终端设备读，通常以行为单位，读到换行符就返回了。
	网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数，
011 ssize_t write(int fd,const void *buf,size_t count);
	成功，返回写入的字节数，出错返回-1并设置errno
	写常规文件时，write的返回值通常等于请求写的字节数count，而向终端设备或网络写则不一定。
012 阻塞和非阻塞
	读/写常规文件时不会阻塞的，不管读/写多少字节在有限的时间内返回，从/向终端设备或者网络读/写则不一定。
	当系统调用一个阻塞的系统函数时，该进程被置于睡眠状态，内核调度其他进程运行，知道该进程等待的事件发生了
	他才有可能继续执行（如，网络接收导数据，或者调用sleep指定的睡眠时间到了），与睡眠状态相对的是运行态
	处在运行状态的进程分两种情况：
		正在被调度执行，CPU处于该进程的上下文环境中，程序计数器（eip）里保存着该进程的指令地址，通用寄存器
		里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。
		就绪状态。该进程不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程，所以该进程在一个
		就绪队列中等待被内核调度。系统中可能同时有多个就绪的进程，那么该调度谁执行呢？内核的调度算法是基于优
		先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到
		机会执行，同时要兼顾用户体验，不能让和用户交互的进程响应太慢。
	阻塞读终端
		#include <unistd.h>
		#include <stdlib.h>
		int main(void)
		{
			char buf[10];
			int n;
			n = read(STDIN_FILENO, buf, 10);
			if (n < 0) {
				perror("read STDIN_FILENO");
				exit(1);
			}
			write(STDOUT_FILENO, buf, n);
			return 0;
		}
		$ ./a.out
		hello（回车）
		hello
		$ ./a.out
		hello world（回车）
		hello worl$ d
		bash: d: command not found
		第一次执行a.out的结果很正常，而第二次执行的过程有点特殊，现在分析一下：
		Shell进程创建a.out进程，a.out进程开始执行，而Shell进程睡眠等待a.out进程退
		出。
		a.out调用read时睡眠等待，直到终端设备输入了换行符才从read返回，read只读走10
		个字符，剩下的字符仍然保存在内核的终端设备输入缓冲区中。
		a.out进程打印并退出，这时Shell进程恢复运行，Shell继续从终端读取用户输入的命
		令，于是读走了终端设备输入缓冲区中剩下的字符d和换行符，把它当成一条命令解释执
		行，结果发现执行不了，没有d这个命令。
		如果在open一个设备时指定了O_NONBLOCK标志，read/write就不会阻塞。以read为例,
		如果设备暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK（或者EAGAIN，这两个
		宏定义的值相同），表示本来应该阻塞在这里（would block，虚拟语气），事实上并没
		有阻塞而是直接返回错误，调用者应该试着再读一次（again）。这种行为方式称为轮询
		（Poll），调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个设备：
		非阻塞I/O有一个缺点，如果所有设备都一直没有数据到达，调用者需要反复查询做无用功。
		使用while去延迟不同查询，延迟等待的时候可以调度其他进程执行。
013 lseek没饿打开的文件都记录着当前读写位置，打开文件时读写位置为0，表示开头。
		O_APPEND是个例外。每次写操作都在文件尾追加数据，然后将读写位置移到新的文件尾
		和标准I/O库的fseek函数相似
014 fcntl 改变文件状态
015 ioctl 向社保发控制和配置命令
		
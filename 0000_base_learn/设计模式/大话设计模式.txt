可维护，有新需求时，需要修改的点较少
可复用，重复使用
可扩展，增加功能很容易
灵活性好
封装、继承、多态降低程序的耦合度
使用设计模式使得程序更加灵活，容易修改，并且易于复用
MVC分层处理，业务和界面分离
设计 计算器
	运算符类
	加法、减法、乘法、除法继承于计算符类。实现新的对已有的没有改动
	实现开方算法
	只需要输入运算符，工厂就会实例化出合适的对象，通过多态返回父类的方式
聚合表示一种弱的拥有关系，体现A对象可以包含B对象，但B对象不是A对象的一部分
合成表示一种强的拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样
促销模式 即策略模式 定义了算法家族，分别封装起来，让他们之间可以互相替换，算法变换不影响使用算法的用户
单一职责，一个类应该仅有一个引起它变化的原因
一个类承担的职责过多，就等于把这些职责耦合起来，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，这种耦合会导致脆弱的设计，发生变化时，设计会遭受到
意想不到的破坏
软件设计真正要做的许多类容，就是发现职责并把那些职责互相分离
开放封闭原则
软件实体可以扩展，不可修改，对于扩展是开放的，对于更改是封闭的
依赖倒转原则
	高层模块不应该依赖底层模块，两个都应该依赖抽象，抽象不应该依赖细节，细节应该依赖抽象
装饰模式 动态的添加一些额外的职责，就增加功能来说，装饰模式比生成子类更灵活
代理模式 为其他对象提供一种代理以控制对这个对象的访问
	远程代理，为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实
	虚拟代理，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象
	安全代理，用来控制真实对象访问时的权限，
	智能指引，当调用真实的对象时，代理处理另外一些事
工厂方法模式
	定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类
原型模式 指定创建对象的种类，通过拷贝这些原型创建新的对象
浅拷贝（指向原来的对象）深拷贝（新的对象）
模板方法模式
	使用继承时，重复的代码上升到父类，不是让每个子类都去重复
迪米特法则
	面向接口编程，而不是实例，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果一个类需要调用另
	外一个类的某个方法，可以通过第三者转发这个调用
外观模式
	子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这个子系统更加容易使用
	首先设计初期阶段，应该有意识的将不同的两个层分离，如经典的三层架构
	层与层之间建立外观Facade
	其次，开发阶段，子系统往往因为不断的重构演化变得越来越复杂
建造者模式
	将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
观察者模式 又叫发布订阅模式 一对多的依赖关系，让多个观察者对象同时监听某个主题对象，这个主题对象状态发送变化时，会通知所有观察者对象，
使得他们能够自动更新自己
157